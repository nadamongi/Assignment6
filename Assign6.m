clc 
%% Import data from text file.
% Script for importing data from the following text file:
%
%    /Users/nadaehab/Documents/MATLAB/house_prices_data_training_data (1).csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2019/04/09 00:00:29

%% Initialize variables.
filename = '/Users/nadaehab/Documents/MATLAB/house_prices_data_training_data (1).csv';
delimiter = ',';
startRow = 2;
endRow = 18000;

%% Format string for each line of text:
%   column1: double (%f)
%	column2: text (%s)
%   column3: double (%f)
%	column4: double (%f)
%   column5: double (%f)
%	column6: double (%f)
%   column7: double (%f)
%	column8: double (%f)
%   column9: double (%f)
%	column10: double (%f)
%   column11: double (%f)
%	column12: double (%f)
%   column13: double (%f)
%	column14: double (%f)
%   column15: double (%f)
%	column16: double (%f)
%   column17: double (%f)
%	column18: double (%f)
%   column19: double (%f)
%	column20: double (%f)
%   column21: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%s%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, endRow-startRow+1, 'Delimiter', delimiter, 'EmptyValue' ,NaN,'HeaderLines', startRow-1, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
id = dataArray{:, 1};
date1 = dataArray{:, 2};
price = dataArray{:, 3};
bedrooms = dataArray{:, 4};
bathrooms = dataArray{:, 5};
sqft_living = dataArray{:, 6};
sqft_lot = dataArray{:, 7};
floors = dataArray{:, 8};
waterfront = dataArray{:, 9};
view1 = dataArray{:, 10};
condition = dataArray{:, 11};
grade = dataArray{:, 12};
sqft_above = dataArray{:, 13};
sqft_basement = dataArray{:, 14};
yr_built = dataArray{:, 15};
yr_renovated = dataArray{:, 16};
zipcode = dataArray{:, 17};
lat = dataArray{:, 18};
long = dataArray{:, 19};
sqft_living15 = dataArray{:, 20};
sqft_lot15 = dataArray{:, 21};




X=[bedrooms,bathrooms,sqft_living,sqft_lot,floors,waterfront,view1,condition,grade,sqft_above,sqft_basement,yr_built,yr_renovated,zipcode,lat,long,sqft_living15,sqft_lot15];
Corr_x = corr(X); 
x_cov=cov(X) ; 
[U S V] =  svd(x_cov);
diagonal=diag(S);

Ksum=0;
for k=1:length(diagonal)
    Ksum=Ksum+diagonal(k);
    alpha=1-(Ksum/sum(diagonal));
    if(alpha<=0.001)
        kfinal=k
        break;
       
    end
   
end
% alpha=1-(Ksum/sum(diagonal))
% k=15;

Reduced_data=U(:,1:kfinal)'*X';
Approximate_data=Reduced_data'*U(1:kfinal,1:kfinal);
% 
error=(1/size(Reduced_data,2))*sum(Approximate_data-Reduced_data');

%linearRegression

alphaa=0.001;
s=length(Reduced_data(1,:));
AppT=Reduced_data';
App_data=[ones(s,1),AppT];
App_data1=featureNormalize(App_data);
priceN=price/mean(price);
theta=zeros(size(App_data1.^2,2),1);
initialcost=ComputeCost(App_data1.^2,priceN,theta);
[theta1, J_history]=GradientDescentMulti(App_data1.^2,priceN,theta,alphaa,initialcost);

%% K-means Clustering 

K=4;

NearestCluster=zeros(size(X,1), 1);

error=[];

XN=featureNormalize(X);
randidx = randperm(size(XN,1));
centroids = XN(randidx(1:K), :);

clustercentroid=[];
xSize=length(XN(1,:));
m=length(XN(:,1));
iterations =100; 
for z=1:iterations 

 for i=1:m
     for j=1:K
            error(j) = sum(sum((XN(i, :) - centroids(j, :)) .^ 2 ));
    end
    [closest_distance, NearestCluster(i)] = min(error);
end
 NearestCluster;
 
%  for i=1:K
%  clustering = XN(find(NearestCluster == i), :)
%  end
 
 
centroids2=[];

% get mean of all indexes of eech feature to result a mean for each a feature at each k of centroid  
for i=1:K
  indexes = find(NearestCluster == i);
  if size(indexes, 1) > 0
    centroids(i, :) = mean(XN(indexes, :));
  end
end
centroids;

% distortion=(1/m)*sum((XN(K,:)-centroids(i,:)))^2;
end

%% K-mean on reduced data set 



Rd=featureNormalize(Reduced_data)';
NearestCluster1=zeros(size(Rd,1), 1);

error1=[];


% randidx1 = randperm(size(Rd,1));
% centroids1 = Rd(randidx1(1:K1), :);
distortion=[];

xSize1=length(Rd(1,:));
m1=length(Rd(:,1));
iterations =100;

% for K1=1:2
randidx1 = randperm(size(Rd,1));
centroids1 = Rd(randidx1(1:K1), :);
for z=1:iterations 

 for i=1:m1
     for j=1:K1
            error1(j) = sum(sum((Rd(i, :) - centroids1(j, :)) .^ 2 ));
     end
   
    [closest_distance1, NearestCluster1(i)] = min(error1);
%      cluster(i) = find(error1(i,:)==min(error(i,:)));
end
 NearestCluster1;


% get mean of all indexes of eech feature to result a mean for each a feature at each k of centroid  
for i=1:K1
  indexes1 = find(NearestCluster1 == i);
  if size(indexes1, 1) > 0
    centroids1(i, :) = mean(Rd(indexes1, :));
%       xi = Rd(find(cluster == indexes1), :);
%     
%       for j=1:size(xi,1)
%           
%  
%      distortion = distortion + sum((xi(j,:) - centroids1(i,:)).^2)/m1;
% for i=1:K1
%      distortion = distortion + sum((Rd(j,:) - centroids1(NearestCluster(i,:))).^2)/m1;

      end
  end
end
centroids1;


% end
% distortion;
%% Anamoly 


%% Anamoly 
m=18;
muu=mean(X);
sigmaa=std(X);
for j=1:17999
for i=1:m 
    
pdf1(j,i)=normpdf(X(j,i),muu(i),sigmaa(i));
end
prodd(j)=prod(pdf1(j,:));
end

Max=10^(-20);
Min=10^(-50);
sumAnamoly=0
for i=1:17999
if prodd(i)>Max || prodd(i)<Min 
    Anamoly=1;
    sumAnamoly=sumAnamoly+1;
else
    Anamoly=0;
end
end
sumAnamoly
%% Clear temporary variables
clearvars filename delimiter startRow endRow formatSpec fileID dataArray ans;